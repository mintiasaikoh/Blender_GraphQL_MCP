"""
Blender MCP (Model Context Protocol) HTTP Serverモジュール
JSONデータとBlenderとの間の通信を行うHTTPサーバーを提供します
"""

import logging
import os
import sys
from typing import Dict, Any, Callable, List, Optional, Union, Tuple
import threading
import time
import json
import traceback

# FastAPIとUvicornをチェック
try:
    import fastapi
    from fastapi import FastAPI, Request, HTTPException
    from fastapi.middleware.cors import CORSMiddleware
    import uvicorn
    HTTP_SERVER_AVAILABLE = True
except ImportError:
    HTTP_SERVER_AVAILABLE = False

# Logger設定
logger = logging.getLogger("blender_json_mcp.http_server")

# GraphQL関連のグローバル変数
GRAPHQL_AVAILABLE = False
query_blender = None  # GraphQLクエリ実行関数の参照


def _load_graphql_dependencies():
    """遅延読み込み関数: GraphQL依存関係を読み込みます"""
    global GRAPHQL_AVAILABLE, query_blender
    
    # 既にロード済みの場合は再利用
    if GRAPHQL_AVAILABLE and query_blender is not None:
        logger.info("GraphQL機能は既にロードされています")
        return True
    
    # まず依存ライブラリがインストールされているか確認
    try:
        import graphql
        logger.info(f"graphql-coreベースライブラリが利用可能です (バージョン: {getattr(graphql, '__version__', 'unknown')})")
    except ImportError as e:
        logger.error(f"graphql-coreライブラリがインストールされていません: {e}")
        logger.info("インストール方法: cd /Applications/Blender.app/Contents/Resources/4.4/python/bin && ./python3.11 -m pip install graphql-core")
        GRAPHQL_AVAILABLE = False
        return False
        
    try:
        # GraphQLモジュールをインポートする前に必要なディレクトリを確認
        import os
        import sys
        addon_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if addon_dir not in sys.path:
            sys.path.append(addon_dir)
            logger.info(f"アドオンディレクトリをパスに追加しました: {addon_dir}")
            
        # GraphQLモジュールを不具合なくインポートできるように再ロード
        import importlib
        if 'blender_json_mcp.graphql.api' in sys.modules:
            importlib.reload(sys.modules['blender_json_mcp.graphql.api'])
            logger.info("blender_json_mcp.graphql.apiを再ロードしました")
            
        # GraphQLモジュールを遅延インポート
        from ..graphql import api
        
        if hasattr(api, 'query_blender'):
            query_blender = api.query_blender
            GRAPHQL_AVAILABLE = getattr(api, 'GRAPHQL_AVAILABLE', True)  # デフォルトでTrueとみなす
            
            # 明示的にモジュールを登録
            if hasattr(api, 'register') and callable(api.register):
                try:
                    api.register()
                    logger.info("GraphQL APIモジュールを登録しました")
                except Exception as e:
                    logger.error(f"GraphQL APIモジュールの登録中にエラーが発生しました: {e}")
                    
            logger.info(f"GraphQL機能を利用可能: {GRAPHQL_AVAILABLE}")
            return GRAPHQL_AVAILABLE
            
        else:
            logger.error("GraphQL APIモジュールにquery_blender関数が見つかりません")
            GRAPHQL_AVAILABLE = False
            return False
            
    except Exception as e:
        logger.error(f"GraphQL依存関係のロード中にエラーが発生しました: {e}")
        import traceback
        logger.debug(traceback.format_exc())
        GRAPHQL_AVAILABLE = False
        return False


class MCPHttpServer:
    """MCPプロトコルを実装するHTTPサーバークラス"""
    
    def __init__(self, host: str = "localhost", port: int = 8765, log_file: str = None):
        """HTTP APIサーバーの初期化"""
        self.host = host
        self.port = port
        self.log_file = log_file or os.path.expanduser("~/blender_mcp_server.log")
        
        # APIの関数レジストリ
        self.api_functions = {}
        
        # FastAPIインスタンス
        self.app = None
        self.server_thread = None
        self.is_running = False
        self.setup_logging()
        
    def setup_logging(self):
        """ロギングの設定"""
        if not os.path.exists(os.path.dirname(self.log_file)):
            os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
        
        file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        file_handler.setLevel(logging.DEBUG)
        
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.setLevel(logging.DEBUG)
    
    def register_function(self, func: Callable, name: str, examples: List[Dict[str, Any]] = None, schema: Dict[str, Any] = None):
        """関数をAPIに登録"""
        self.api_functions[name] = {
            'func': func,
            'examples': examples or [],
            'schema': schema or {}
        }
        logger.info(f"関数 '{name}' をAPIに登録しました")
    
    def start(self) -> bool:
        """サーバーを起動"""
        if not HTTP_SERVER_AVAILABLE:
            logger.error("一部の依存関係が不足しているため、サーバーを起動できません")
            return False
        
        if self.is_running:
            logger.warning("サーバーは既に実行中です")
            return True
        
        try:
            # FastAPIアプリを作成
            self.app = FastAPI(title="Blender MCP API", version="1.0.0")
            
            # CORSミドルウェアを追加
            self.app.add_middleware(
                CORSMiddleware,
                allow_origins=["*"],
                allow_credentials=True,
                allow_methods=["*"],
                allow_headers=["*"],
            )
            
            # ルートとルーティングを設定
            self._setup_routes()
            
            # 別スレッドでサーバーを起動
            self.server_thread = threading.Thread(
                target=self._run_server,
                daemon=True
            )
            self.server_thread.start()
            
            # 起動を少し待つ
            time.sleep(1)
            self.is_running = True
            logger.info(f"MCPサーバーを開始: {self.host}:{self.port}")
            return True
            
        except Exception as e:
            logger.error(f"サーバー起動エラー: {e}")
            import traceback
            logger.debug(traceback.format_exc())
            return False
    
    def stop(self) -> bool:
        """サーバーを停止"""
        if not self.is_running:
            logger.warning("サーバーは実行中ではありません")
            return True
        
        try:
            self.is_running = False
            # サーバースレッドを終了
            # UvicornサーバーのAPIに直接アクセスする方法はないため、
            # スレッドをデーモンとして実行し、終了時に自動的に終了します
            logger.info("MCPサーバーを停止")
            return True
        except Exception as e:
            logger.error(f"サーバー停止エラー: {e}")
            return False
    
    def _run_server(self):
        """サーバーを起動するプライベートメソッド"""
        try:
            uvicorn.run(
                self.app,
                host=self.host,
                port=self.port,
                log_level="error"
            )
        except Exception as e:
            logger.error(f"サーバー実行エラー: {e}")
    
    def _setup_routes(self):
        """APIルートをセットアップ"""
        try:
            # ベースルート
            @self.app.get("/")
            async def root():
                return {"message": "Blender MCP API Server", "status": "running"}
            
            # GraphQL依存関係をロード
            graphql_loaded = _load_graphql_dependencies()
            logger.info(f"GraphQLロード状態: {graphql_loaded}")
            
            # シンプル化されたGraphQL APIの実装
            @self.app.post("/graphql")
            async def graphql_endpoint(request: Request):
                """
                シンプル化されたGraphQLスタイルAPIエンドポイント
                """
                try:
                    # リクエストボディを解析
                    body = await request.json()
                    operation = body.get("operation", "")
                    params = body.get("params", {})
                    
                    # 従来のGraphQL形式のための後方互換性
                    if "query" in body:
                        query = body.get("query", "")
                        variables = body.get("variables", {})
                        
                        # 単純な文字列チェックでオペレーションを判定
                        if "hello" in query:
                            operation = "hello"
                        elif "createObject" in query:
                            operation = "createObject"
                            params = variables
                        elif "transformObject" in query:
                            operation = "transformObject"
                            params = variables
                        elif "deleteObject" in query:
                            operation = "deleteObject"
                            params = variables
                        elif "sceneInfo" in query:
                            operation = "sceneInfo"
                        elif "materials" in query and not "object" in query:
                            operation = "materials"
                        elif "object" in query and "name" in variables:
                            operation = "object"
                            params = variables
                    
                    # ログ記録
                    logger.info(f"GraphQL API リクエスト: operation={operation}, params={params}")
                    
                    import bpy
                    from math import radians, degrees
                    
                    # オペレーション名が指定されていない場合はエラー
                    if not operation:
                        return {"errors": [{"message": "operation パラメーターが必要です"}]}
                        
                    #------------------------------------------------
                    # オペレーションごとの処理を実装
                    #------------------------------------------------
                    
                    # 1. Hello Worldクエリ
                    if operation == "hello":
                        return {"data": {"hello": "Hello from Blender MCP GraphQL API!"}}
                    
                    # 2. シーン情報クエリ
                    elif operation == "sceneInfo":
                        scene = bpy.context.scene
                        result = {
                            "name": scene.name,
                            "frame_current": scene.frame_current,
                            "frame_start": scene.frame_start,
                            "frame_end": scene.frame_end,
                            "objects": []
                        }
                        
                        # 全オブジェクト情報を取得
                        for obj in scene.objects:
                            obj_data = {
                                "name": obj.name,
                                "type": obj.type,
                                "location": {
                                    "x": obj.location.x,
                                    "y": obj.location.y,
                                    "z": obj.location.z
                                }
                            }
                            result["objects"].append(obj_data)
                        
                        return {"data": {"sceneInfo": result}}
                    
                    # 3. 特定のオブジェクト情報クエリ
                    elif operation == "object" and "name" in params:
                        obj_name = params.get("name")
                        if obj_name in bpy.data.objects:
                            obj = bpy.data.objects[obj_name]
                            result = {
                                "name": obj.name,
                                "type": obj.type,
                                "location": {
                                    "x": obj.location.x,
                                    "y": obj.location.y,
                                    "z": obj.location.z
                                },
                                "rotation": {
                                    "x": degrees(obj.rotation_euler.x),
                                    "y": degrees(obj.rotation_euler.y),
                                    "z": degrees(obj.rotation_euler.z)
                                },
                                "scale": {
                                    "x": obj.scale.x,
                                    "y": obj.scale.y,
                                    "z": obj.scale.z
                                }
                            }
                            return {"data": {"object": result}}
                        else:
                            return {"errors": [{"message": f"オブジェクト '{obj_name}' が見つかりません"}]}
                    
                    # 4. マテリアル一覧クエリ
                    elif operation == "materials":
                        materials = []
                        for mat in bpy.data.materials:
                            materials.append({
                                "name": mat.name,
                                "use_nodes": mat.use_nodes
                            })
                        return {"data": {"materials": materials}}
                    
                    # 5. オブジェクト作成ミューテーション
                    elif operation == "createObject":
                        obj_type = params.get("type", "CUBE").upper()
                        obj_name = params.get("name", f"Object_{obj_type}")
                        
                        # 位置情報の処理
                        location = params.get("location", {"x": 0, "y": 0, "z": 0})
                        if isinstance(location, dict):
                            x = location.get("x", 0)
                            y = location.get("y", 0)
                            z = location.get("z", 0)
                        elif isinstance(location, (list, tuple)) and len(location) >= 3:
                            x, y, z = location[0], location[1], location[2]
                        else:
                            x, y, z = 0, 0, 0
                        
                        try:
                            # オブジェクト作成
                            if obj_type == "CUBE":
                                bpy.ops.mesh.primitive_cube_add(location=(x, y, z))
                            elif obj_type == "SPHERE":
                                bpy.ops.mesh.primitive_uv_sphere_add(location=(x, y, z))
                            elif obj_type == "CYLINDER":
                                bpy.ops.mesh.primitive_cylinder_add(location=(x, y, z))
                            elif obj_type == "CONE":
                                bpy.ops.mesh.primitive_cone_add(location=(x, y, z))
                            elif obj_type == "PLANE":
                                bpy.ops.mesh.primitive_plane_add(location=(x, y, z))
                            elif obj_type == "EMPTY":
                                bpy.ops.object.empty_add(type='PLAIN_AXES', location=(x, y, z))
                            else:
                                return {"errors": [{"message": f"サポートされていないオブジェクトタイプ: {obj_type}"}]}
                            
                            # 作成されたオブジェクトに名前を設定
                            obj = bpy.context.active_object
                            obj.name = obj_name
                            
                            # レスポンスを返す
                            return {
                                "data": {
                                    "createObject": {
                                        "success": True,
                                        "object": {
                                            "name": obj.name,
                                            "type": obj.type,
                                            "location": {
                                                "x": obj.location.x,
                                                "y": obj.location.y,
                                                "z": obj.location.z
                                            }
                                        }
                                    }
                                }
                            }
                        except Exception as e:
                            logger.error(f"オブジェクト作成エラー: {str(e)}")
                            return {"errors": [{"message": f"オブジェクト作成エラー: {str(e)}"}]}
                    
                    # 6. オブジェクト変換ミューテーション
                    elif operation == "transformObject" and "name" in params:
                        obj_name = params.get("name")
                        
                        if obj_name not in bpy.data.objects:
                            return {"errors": [{"message": f"オブジェクト '{obj_name}' が見つかりません"}]}
                        
                        obj = bpy.data.objects[obj_name]
                        
                        try:
                            # 位置変更
                            if "location" in params:
                                loc = params["location"]
                                if isinstance(loc, dict):
                                    if "x" in loc: obj.location.x = float(loc["x"])
                                    if "y" in loc: obj.location.y = float(loc["y"])
                                    if "z" in loc: obj.location.z = float(loc["z"])
                                elif isinstance(loc, (list, tuple)) and len(loc) >= 3:
                                    obj.location.x = float(loc[0])
                                    obj.location.y = float(loc[1])
                                    obj.location.z = float(loc[2])
                            
                            # 回転変更
                            if "rotation" in params:
                                rot = params["rotation"]
                                if isinstance(rot, dict):
                                    if "x" in rot: obj.rotation_euler.x = radians(float(rot["x"]))
                                    if "y" in rot: obj.rotation_euler.y = radians(float(rot["y"]))
                                    if "z" in rot: obj.rotation_euler.z = radians(float(rot["z"]))
                                elif isinstance(rot, (list, tuple)) and len(rot) >= 3:
                                    obj.rotation_euler.x = radians(float(rot[0]))
                                    obj.rotation_euler.y = radians(float(rot[1]))
                                    obj.rotation_euler.z = radians(float(rot[2]))
                            
                            # スケール変更
                            if "scale" in params:
                                scale = params["scale"]
                                if isinstance(scale, dict):
                                    if "x" in scale: obj.scale.x = float(scale["x"])
                                    if "y" in scale: obj.scale.y = float(scale["y"])
                                    if "z" in scale: obj.scale.z = float(scale["z"])
                                elif isinstance(scale, (list, tuple)) and len(scale) >= 3:
                                    obj.scale.x = float(scale[0])
                                    obj.scale.y = float(scale[1])
                                    obj.scale.z = float(scale[2])
                            
                            # レスポンスを返す
                            return {
                                "data": {
                                    "transformObject": {
                                        "success": True,
                                        "object": {
                                            "name": obj.name,
                                            "location": {
                                                "x": obj.location.x,
                                                "y": obj.location.y,
                                                "z": obj.location.z
                                            },
                                            "rotation": {
                                                "x": degrees(obj.rotation_euler.x),
                                                "y": degrees(obj.rotation_euler.y),
                                                "z": degrees(obj.rotation_euler.z)
                                            },
                                            "scale": {
                                                "x": obj.scale.x,
                                                "y": obj.scale.y,
                                                "z": obj.scale.z
                                            }
                                        }
                                    }
                                }
                            }
                        except Exception as e:
                            logger.error(f"オブジェクト変換エラー: {str(e)}")
                            return {"errors": [{"message": f"オブジェクト変換エラー: {str(e)}"}]}
                    
                    # 7. オブジェクト削除ミューテーション
                    elif operation == "deleteObject" and "name" in params:
                        obj_name = params.get("name")
                        
                        try:
                            if obj_name not in bpy.data.objects:
                                return {"errors": [{"message": f"オブジェクト '{obj_name}' が見つかりません"}]}
                            
                            obj = bpy.data.objects[obj_name]
                            bpy.data.objects.remove(obj)
                            
                            return {
                                "data": {
                                    "deleteObject": {
                                        "success": True,
                                        "message": f"オブジェクト '{obj_name}' を削除しました"
                                    }
                                }
                            }
                        except Exception as e:
                            logger.error(f"オブジェクト削除エラー: {str(e)}")
                            return {"errors": [{"message": f"オブジェクト削除エラー: {str(e)}"}]}
                    
                    # サポートされていないオペレーションの場合はエラーを返す
                    else:
                        return {"errors": [{"message": f"サポートされていないオペレーション: {operation}"}]}
                
                except Exception as e:
                    logger.error(f"GraphQLエンドポイントエラー: {str(e)}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return {"errors": [{"message": f"GraphQLエンドポイントエラー: {str(e)}"}]}
            
            # GraphQLエンドポイントの設定完了をログ記録
            logger.info("GraphQLエンドポイントを追加: /graphql")
            
            # エラーハンドラの追加
            try:
                @self.app.exception_handler(HTTPException)
                async def http_exception_handler(request, exc):
                    return {"error": {"code": exc.status_code, "message": str(exc.detail)}}
                
                @self.app.exception_handler(Exception)
                async def general_exception_handler(request, exc):
                    logger.error(f"サーバーエラー: {exc}")
                    return {"error": {"code": "SERVER_ERROR", "message": str(exc)}}
                
            except Exception as e:
                logger.error(f"エラーハンドラの追加中にエラーが発生しました: {e}")
            
            # MCPコマンドルートを追加
            @self.app.post("/mcp/command")
            async def handle_mcp_command(request: Request):
                try:
                    # リクエストボディを解析
                    body = await request.json()
                    
                    # 必須パラメータの確認
                    if "name" not in body or "parameters" not in body:
                        return {"error": {"code": "INVALID_REQUEST", "message": "Invalid MCP request format. 'name' and 'parameters' fields are required."}}
                    
                    command_name = body["name"]
                    parameters = body["parameters"]
                    
                    # コマンドの存在確認
                    if command_name not in self.api_functions:
                        available_tools = list(self.api_functions.keys())
                        return {"error": {"code": "UNKNOWN_TOOL", "message": f"Unknown tool: {command_name}", "details": {"available_tools": available_tools}}}
                    
                    # コマンドを実行
                    func_info = self.api_functions[command_name]
                    func = func_info["func"]
                    schema = func_info["schema"]
                    
                    # スキーマがある場合はパラメータを検証
                    if schema and "required" in schema:
                        required_params = schema.get("required", [])
                        for param in required_params:
                            if param not in parameters:
                                return {"error": {"code": "MISSING_PARAMETER", "message": f"Missing required parameter: {param}", "details": {"required_parameters": required_params}}}
                    
                    # 関数を実行して結果を返す
                    try:
                        result = func(**parameters)
                        return {"result": result}
                    except Exception as e:
                        logger.error(f"コマンド実行エラー: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        return {"error": {"code": "EXECUTION_ERROR", "message": str(e)}}
                    
                except Exception as e:
                    logger.error(f"MCP コマンド処理エラー: {e}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return {"error": {"code": "SERVER_ERROR", "message": str(e)}}
            
            logger.info("MCPコマンドエンドポイントを追加: /mcp/command")
            
        except Exception as e:
            logger.error(f"ルート設定エラー: {e}")
            import traceback
            logger.debug(traceback.format_exc())
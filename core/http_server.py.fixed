"""
Blender MCP (Model Context Protocol) HTTP Serverモジュール
JSONデータとBlenderとの間の通信を行うHTTPサーバーを提供します
"""

import logging
import os
import sys
from typing import Dict, Any, Callable, List, Optional, Union, Tuple
import threading
import time
import json
import traceback

# FastAPIとUvicornをチェック
try:
    import fastapi
    from fastapi import FastAPI, Request, HTTPException
    from fastapi.middleware.cors import CORSMiddleware
    import uvicorn
    HTTP_SERVER_AVAILABLE = True
except ImportError:
    HTTP_SERVER_AVAILABLE = False

# Logger設定
logger = logging.getLogger("blender_json_mcp.http_server")

# GraphQL関連のグローバル変数
GRAPHQL_AVAILABLE = False
query_blender = None  # GraphQLクエリ実行関数の参照


def _load_graphql_dependencies():
    """遅延読み込み関数: GraphQL依存関係を読み込みます"""
    global GRAPHQL_AVAILABLE, query_blender
    
    # 既にロード済みの場合は再利用
    if GRAPHQL_AVAILABLE and query_blender is not None:
        logger.info("GraphQL機能は既にロードされています")
        return True
    
    # まず依存ライブラリがインストールされているか確認
    try:
        import graphql
        logger.info(f"graphql-coreベースライブラリが利用可能です (バージョン: {getattr(graphql, '__version__', 'unknown')})")
    except ImportError as e:
        logger.error(f"graphql-coreライブラリがインストールされていません: {e}")
        logger.info("インストール方法: cd /Applications/Blender.app/Contents/Resources/4.4/python/bin && ./python3.11 -m pip install graphql-core")
        GRAPHQL_AVAILABLE = False
        return False
        
    try:
        # GraphQLモジュールをインポートする前に必要なディレクトリを確認
        import os
        import sys
        addon_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if addon_dir not in sys.path:
            sys.path.append(addon_dir)
            logger.info(f"アドオンディレクトリをパスに追加しました: {addon_dir}")
            
        # GraphQLモジュールを不具合なくインポートできるように再ロード
        import importlib
        if 'blender_json_mcp.graphql.api' in sys.modules:
            importlib.reload(sys.modules['blender_json_mcp.graphql.api'])
            logger.info("blender_json_mcp.graphql.apiを再ロードしました")
            
        # GraphQLモジュールを遅延インポート
        from ..graphql import api
        
        if hasattr(api, 'query_blender'):
            query_blender = api.query_blender
            GRAPHQL_AVAILABLE = getattr(api, 'GRAPHQL_AVAILABLE', True)  # デフォルトでTrueとみなす
            
            # 明示的にモジュールを登録
            if hasattr(api, 'register') and callable(api.register):
                try:
                    api.register()
                    logger.info("GraphQL APIモジュールを登録しました")
                except Exception as e:
                    logger.error(f"GraphQL APIモジュールの登録中にエラーが発生しました: {e}")
                    
            logger.info(f"GraphQL機能を利用可能: {GRAPHQL_AVAILABLE}")
            return GRAPHQL_AVAILABLE
            
        else:
            logger.error("GraphQL APIモジュールにquery_blender関数が見つかりません")
            GRAPHQL_AVAILABLE = False
            return False
            
    except Exception as e:
        logger.error(f"GraphQL依存関係のロード中にエラーが発生しました: {e}")
        import traceback
        logger.debug(traceback.format_exc())
        GRAPHQL_AVAILABLE = False
        return False


class MCPHttpServer:
    """MCPプロトコルを実装するHTTPサーバークラス"""
    
    def __init__(self, host: str = "localhost", port: int = 8765, log_file: str = None):
        """HTTP APIサーバーの初期化"""
        self.host = host
        self.port = port
        self.log_file = log_file or os.path.expanduser("~/blender_mcp_server.log")
        
        # APIの関数レジストリ
        self.api_functions = {}
        
        # FastAPIインスタンス
        self.app = None
        self.server_thread = None
        self.is_running = False
        self.setup_logging()
        
    def setup_logging(self):
        """ロギングの設定"""
        if not os.path.exists(os.path.dirname(self.log_file)):
            os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
        
        file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        file_handler.setLevel(logging.DEBUG)
        
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.setLevel(logging.DEBUG)
    
    def register_function(self, func: Callable, name: str, examples: List[Dict[str, Any]] = None, schema: Dict[str, Any] = None):
        """関数をAPIに登録"""
        self.api_functions[name] = {
            'func': func,
            'examples': examples or [],
            'schema': schema or {}
        }
        logger.info(f"関数 '{name}' をAPIに登録しました")
    
    def start(self) -> bool:
        """サーバーを起動"""
        if not HTTP_SERVER_AVAILABLE:
            logger.error("一部の依存関係が不足しているため、サーバーを起動できません")
            return False
        
        if self.is_running:
            logger.warning("サーバーは既に実行中です")
            return True
        
        try:
            # FastAPIアプリを作成
            self.app = FastAPI(title="Blender MCP API", version="1.0.0")
            
            # CORSミドルウェアを追加
            self.app.add_middleware(
                CORSMiddleware,
                allow_origins=["*"],
                allow_credentials=True,
                allow_methods=["*"],
                allow_headers=["*"],
            )
            
            # ルートとルーティングを設定
            self._setup_routes()
            
            # 別スレッドでサーバーを起動
            self.server_thread = threading.Thread(
                target=self._run_server,
                daemon=True
            )
            self.server_thread.start()
            
            # 起動を少し待つ
            time.sleep(1)
            self.is_running = True
            logger.info(f"MCPサーバーを開始: {self.host}:{self.port}")
            return True
            
        except Exception as e:
            logger.error(f"サーバー起動エラー: {e}")
            import traceback
            logger.debug(traceback.format_exc())
            return False
    
    def stop(self) -> bool:
        """サーバーを停止"""
        if not self.is_running:
            logger.warning("サーバーは実行中ではありません")
            return True
        
        try:
            self.is_running = False
            # サーバースレッドを終了
            # UvicornサーバーのAPIに直接アクセスする方法はないため、
            # スレッドをデーモンとして実行し、終了時に自動的に終了します
            logger.info("MCPサーバーを停止")
            return True
        except Exception as e:
            logger.error(f"サーバー停止エラー: {e}")
            return False
    
    def _run_server(self):
        """サーバーを起動するプライベートメソッド"""
        try:
            uvicorn.run(
                self.app,
                host=self.host,
                port=self.port,
                log_level="error"
            )
        except Exception as e:
            logger.error(f"サーバー実行エラー: {e}")
    
    def _setup_routes(self):
        """APIルートをセットアップ"""
        try:
            # ベースルート
            @self.app.get("/")
            async def root():
                return {"message": "Blender MCP API Server", "status": "running"}
            
            # GraphQL依存関係をロード
            graphql_loaded = _load_graphql_dependencies()
            logger.info(f"GraphQLロード状態: {graphql_loaded}")
            
            # 正規のGraphQLライブラリを使用したGraphQLエンドポイント
            @self.app.post("/graphql")
            async def graphql_endpoint(request: Request):
                """
                GraphQL標準に準拠したAPIエンドポイント
                """
                try:
                    # リクエストボディを解析
                    body = await request.json()
                    query = body.get("query")
                    variables = body.get("variables", {})
                    operation_name = body.get("operationName")
                    
                    # ログ記録
                    logger.info(f"GraphQLリクエスト受信: {query[:100] if query else ''}...")
                    logger.info(f"Operation: {operation_name}, Variables: {variables}")
                    
                    # GraphQL依存関係をチェック
                    if not GRAPHQL_AVAILABLE:
                        logger.error("GraphQLライブラリがインストールされていません")
                        return {"errors": [{"message": "GraphQLライブラリが利用できません"}]}
                    
                    # クエリが空の場合はエラー
                    if not query:
                        return {"errors": [{"message": "queryパラメータが必要です"}]}
                    
                    # GraphQL APIモジュールを短約チェック
                    from ..graphql import api as graphql_api
                    
                    if not hasattr(graphql_api, 'query_blender'):
                        logger.error("GraphQL APIモジュールにquery_blender関数が見つかりません")
                        return {"errors": [{"message": "GraphQL APIが正しく構成されていません"}]}
                    
                    # GraphQLクエリを実行
                    result = graphql_api.query_blender(query, variables)
                    
                    # 結果を返す
                    return result
                    
                except Exception as e:
                    logger.error(f"GraphQLエンドポイントエラー: {str(e)}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return {"errors": [{"message": f"GraphQLエンドポイントエラー: {str(e)}"}]}
            
            # GraphQLエンドポイントの設定完了をログ記録
            logger.info("GraphQLエンドポイントを追加: /graphql")
            
            # エラーハンドラの追加
            try:
                @self.app.exception_handler(HTTPException)
                async def http_exception_handler(request, exc):
                    return {"error": {"code": exc.status_code, "message": str(exc.detail)}}
                
                @self.app.exception_handler(Exception)
                async def general_exception_handler(request, exc):
                    logger.error(f"サーバーエラー: {exc}")
                    return {"error": {"code": "SERVER_ERROR", "message": str(exc)}}
                
            except Exception as e:
                logger.error(f"エラーハンドラの追加中にエラーが発生しました: {e}")
            
            # MCPコマンドルートを追加
            @self.app.post("/mcp/command")
            async def handle_mcp_command(request: Request):
                try:
                    # リクエストボディを解析
                    body = await request.json()
                    
                    # 必須パラメータの確認
                    if "name" not in body or "parameters" not in body:
                        return {"error": {"code": "INVALID_REQUEST", "message": "Invalid MCP request format. 'name' and 'parameters' fields are required."}}
                    
                    command_name = body["name"]
                    parameters = body["parameters"]
                    
                    # コマンドの存在確認
                    if command_name not in self.api_functions:
                        available_tools = list(self.api_functions.keys())
                        return {"error": {"code": "UNKNOWN_TOOL", "message": f"Unknown tool: {command_name}", "details": {"available_tools": available_tools}}}
                    
                    # コマンドを実行
                    func_info = self.api_functions[command_name]
                    func = func_info["func"]
                    schema = func_info["schema"]
                    
                    # スキーマがある場合はパラメータを検証
                    if schema and "required" in schema:
                        required_params = schema.get("required", [])
                        for param in required_params:
                            if param not in parameters:
                                return {"error": {"code": "MISSING_PARAMETER", "message": f"Missing required parameter: {param}", "details": {"required_parameters": required_params}}}
                    
                    # 関数を実行して結果を返す
                    try:
                        result = func(**parameters)
                        return {"result": result}
                    except Exception as e:
                        logger.error(f"コマンド実行エラー: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        return {"error": {"code": "EXECUTION_ERROR", "message": str(e)}}
                    
                except Exception as e:
                    logger.error(f"MCP コマンド処理エラー: {e}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return {"error": {"code": "SERVER_ERROR", "message": str(e)}}
            
            logger.info("MCPコマンドエンドポイントを追加: /mcp/command")
            
        except Exception as e:
            logger.error(f"ルート設定エラー: {e}")
            import traceback
            logger.debug(traceback.format_exc())